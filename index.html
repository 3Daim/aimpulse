<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Aimpulse</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap');
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

  body {
    margin: 0;
    overflow: hidden;
    cursor: crosshair;
    background: #000000;
    color: white;
    font-family: Arial, sans-serif;
    position: relative;
  }
  #instructions {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    user-select: none;
    pointer-events: none;
    z-index: 10;
    font-weight: bold;
    font-family: 'Share Tech Mono', monospace, Arial, sans-serif;
  }
  #crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin-left: -10px;
    margin-top: -10px;
    pointer-events: none;
    z-index: 10;
  }
  #crosshair:before, #crosshair:after {
    content: '';
    position: absolute;
    background: white;
  }
  #crosshair:before {
    left: 50%;
    top: 0;
    width: 2px;
    height: 100%;
    margin-left: -1px;
  }
  #crosshair:after {
    top: 50%;
    left: 0;
    width: 100%;
    height: 2px;
    margin-top: -1px;
  }
  #score {
    position: fixed;
    top: 15px;
    left: 15px;
    color: #00ff99;
    font-weight: bold;
    font-size: 28px;
    user-select: none;
    z-index: 20;
    font-family: 'Share Tech Mono', monospace, Arial, sans-serif;
  }
  .dg {
    z-index: 9999 !important;
  }
  .dg.ac {
    top: 10px !important;
    right: 10px !important;
    left: auto !important;
  }
  #pauseOverlay {
    position: fixed;
    inset: 0;
    background: radial-gradient(circle at center, rgba(0, 16, 34, 0.4) 0%, rgba(0, 0, 0, 0.3) 80%);
    color: #00ff99;
    font-family: 'Orbitron', monospace, Arial, sans-serif;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    z-index: 50;
    cursor: pointer;
    user-select: none;
  }
  #pauseOverlay.visible {
    opacity: 1;
    pointer-events: auto;
  }
  #pauseOverlay h1.title {
    font-size: 5rem;
    text-shadow: 0 0 8px #00ff99, 0 0 20px #00ff99, 0 0 30px #00ff99;
    margin-bottom: 0.1em;
  }
  #pauseOverlay h2.subtitle {
    font-size: 2rem;
    text-shadow: 0 0 6px #00ff99, 0 0 12px #00ff99;
    margin-top: 0;
    text-transform: uppercase;
    letter-spacing: 2px;
  }
</style>
</head>
<body>

<div id="instructions"><span style="text-decoration: underline;">PAUSED</span><br>Click to lock in!</div>
<div id="crosshair"></div>
<div id="score">Score: 0</div>

<div id="pauseOverlay" aria-hidden="true" role="dialog" aria-modal="true" tabindex="0">
  <h1 class="title">Aimpulse</h1>
  <h2 class="subtitle">3D Holographic Target Practice</h2>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>

<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 1.6, 0);

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000);
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0x888888);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(5, 10, 7);
scene.add(directionalLight);

const params = {
  targetDistance: 5,
  targetCount: 5,
  targetSize: 0.7,
  targetOpacity: 0.5,
  targetColor: '#00ff99',
  bgColor: '#000000',
  videoFile: 'vaporwave_sd.mp4'  // default video
};

const videoFiles = [
  'bright_green_grid.mp4',  'controls.mp4', 'grid.mp4',  'vaporwave_sunset.mp4', 'vaporwave_sd.mp4'
];

// Create video element and texture
const video = document.createElement('video');
video.src = params.videoFile;  // Use the default video from params
video.crossOrigin = 'anonymous';
video.loop = true;
video.muted = true;
video.playsInline = true;
video.play().catch(e => {
  console.warn("Video autoplay prevented; user interaction needed.", e);
});
const videoTexture = new THREE.VideoTexture(video);
videoTexture.minFilter = THREE.LinearFilter;
videoTexture.magFilter = THREE.LinearFilter;
videoTexture.format = THREE.RGBAFormat;

function calculateWallSize(distance) {
  const fovRad = THREE.MathUtils.degToRad(camera.fov);
  const visibleHeight = 2 * distance * Math.tan(fovRad / 2);
  const height = visibleHeight * 0.9;
  const width = (16/9) * height;
  return {width, height};
}

function isOverlapping(pos) {
  for (const c of cubes) {
    const dx = c.position.x - pos.x;
    const dy = c.position.y - pos.y;
    if (dx*dx + dy*dy < (params.targetSize + margin)**2) return true;
  }
  return false;
}

function createTargetMaterials(colorHex) {
  const transparent = params.targetOpacity < 1.0;
  return {
    normal: new THREE.MeshStandardMaterial({
      color: colorHex,
      roughness: 0.4,
      metalness: 0.6,
      emissive: new THREE.Color(colorHex).multiplyScalar(0.5),
      emissiveIntensity: 0.5,
      transparent: transparent,
      opacity: params.targetOpacity
    }),
    wireframe: new THREE.MeshBasicMaterial({
      color: colorHex,
      wireframe: true,
      transparent: false,
      opacity: 1.0
    })
  };
}

function spawnCube() {
  let attempts = 0;
  let pos;
  do {
    const x = (Math.random() - 0.5) * planeWidth * 0.9;
    const y = 1.6 + (Math.random() - 0.5) * planeHeight * 0.9;
    pos = new THREE.Vector3(x, y, -params.targetDistance + params.targetSize / 2 + zOffset);
    attempts++;
    if (attempts > maxAttempts) {
      console.warn("Max spawn attempts reached");
      break;
    }
  } while (isOverlapping(pos));

  const materials = createTargetMaterials(params.targetColor);
  const geometry = new THREE.BoxGeometry(params.targetSize, params.targetSize, params.targetSize);

  const cube = new THREE.Mesh(geometry, materials.normal);
  cube.userData = { materials };

  const wireframe = new THREE.Mesh(geometry, materials.wireframe);
  wireframe.renderOrder = 1;
  wireframe.material.depthTest = false;
  cube.add(wireframe);

  cube.position.copy(pos);
  cubes.push(cube);
  scene.add(cube);
}

function adjustTargetCount() {
  const currentCount = cubes.length;
  const desiredCount = params.targetCount;
  if (desiredCount > currentCount) {
    for (let i=0; i<desiredCount - currentCount; i++) spawnCube();
  } else if (desiredCount < currentCount) {
    for (let i=0; i<currentCount - desiredCount; i++) {
      const cubeToRemove = cubes.pop();
      scene.remove(cubeToRemove);
      cubeToRemove.geometry.dispose();
      cubeToRemove.userData.materials.normal.dispose();
      cubeToRemove.userData.materials.wireframe.dispose();
    }
  }
}

function init() {
  const size = calculateWallSize(params.targetDistance);
  planeWidth = size.width;
  planeHeight = size.height;

  if (backPlane) {
    scene.remove(backPlane);
    backPlane.geometry.dispose();
    backPlane.material.dispose();
  }

  backPlane = new THREE.Mesh(
    new THREE.PlaneGeometry(planeWidth, planeHeight),
    new THREE.MeshBasicMaterial({map: videoTexture, side: THREE.DoubleSide})
  );
  backPlane.position.set(0, 1.6, -params.targetDistance - 0.5);
  scene.add(backPlane);

  adjustTargetCount();
  updateColors();
}

function updateWallAndCubes() {
  const size = calculateWallSize(params.targetDistance);
  planeWidth = size.width;
  planeHeight = size.height;

  if (backPlane) {
    backPlane.geometry.dispose();
    backPlane.geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
    backPlane.position.z = -params.targetDistance - 0.5;
  }

  cubes.forEach(cube => {
    cube.position.z = -params.targetDistance + params.targetSize / 2 + zOffset;
    cube.position.x = THREE.MathUtils.clamp(cube.position.x, -planeWidth * 0.45, planeWidth * 0.45);
    cube.position.y = THREE.MathUtils.clamp(cube.position.y, 1.6 - planeHeight * 0.45, 1.6 + planeHeight * 0.45);
  });
}

function updateColors() {
  renderer.setClearColor(params.bgColor);

  cubes.forEach(cube => {
    cube.userData.materials.normal.dispose();
    cube.userData.materials.wireframe.dispose();

    const newMaterials = createTargetMaterials(params.targetColor);

    newMaterials.normal.opacity = params.targetOpacity;
    newMaterials.normal.transparent = params.targetOpacity < 1;

    cube.userData.materials = newMaterials;
    cube.material = newMaterials.normal;

    if (cube.children.length > 0) {
      cube.children[0].material = newMaterials.wireframe;
      cube.children[0].material.transparent = false;
      cube.children[0].material.opacity = 1.0;
    }

    cube.material.emissive = new THREE.Color(params.targetColor).multiplyScalar(0.5);
    cube.material.emissiveIntensity = 0.5;
  });
}

let pitch = 0, yaw = 0;
const sensitivity = 0.002;
function onMouseMove(e) {
  if (document.pointerLockElement === renderer.domElement) {
    yaw -= e.movementX * sensitivity;
    pitch -= e.movementY * sensitivity;
    pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
    camera.rotation.x = pitch;
    camera.rotation.y = yaw;
  }
}

renderer.domElement.addEventListener('click', () => {
  renderer.domElement.requestPointerLock();
});

const instructions = document.getElementById('instructions');
const pauseOverlay = document.getElementById('pauseOverlay');

document.addEventListener('pointerlockchange', () => {
  if (document.pointerLockElement === renderer.domElement) {
    instructions.style.display = 'none';
    gui.domElement.style.display = 'none';
    pauseOverlay.classList.remove('visible');
    document.addEventListener('mousemove', onMouseMove);
    isPaused = false;
  } else {
    instructions.style.display = 'block';
    gui.domElement.style.display = 'block';
    pauseOverlay.classList.add('visible');
    document.removeEventListener('mousemove', onMouseMove);
    isPaused = true;
  }
});

pauseOverlay.addEventListener('click', () => {
  renderer.domElement.requestPointerLock();
});

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2(0,0);
let hoveredCube = null;
const scoreDisplay = document.getElementById('score');
let score = 0;

renderer.domElement.addEventListener('mousedown', (event) => {
  if(event.button === 0 && document.pointerLockElement === renderer.domElement && !isPaused) {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(cubes);
    if(intersects.length > 0){
      const clickedCube = intersects[0].object;
      scene.remove(clickedCube);
      const idx = cubes.indexOf(clickedCube);
      if(idx > -1) cubes.splice(idx, 1);
      score++;
      scoreDisplay.textContent = `Score: ${score}`;
      spawnCube();
      adjustTargetCount();
    }
  }
});

function animate(){
  requestAnimationFrame(animate);

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(cubes);
  if(intersects.length > 0 && !isPaused) {
    const newHovered = intersects[0].object;
    if(hoveredCube !== newHovered){
      if(hoveredCube) {
        hoveredCube.material.emissive.copy(new THREE.Color(params.targetColor).multiplyScalar(0.5));
      }
      hoveredCube = newHovered;
      hoveredCube.material.emissive.copy(new THREE.Color(params.targetColor).multiplyScalar(8.0));
    }
  } else if(hoveredCube){
    hoveredCube.material.emissive.copy(new THREE.Color(params.targetColor).multiplyScalar(0.5));
    hoveredCube = null;
  }

  cubes.forEach(cube => {
    cube.rotation.x += 0.007;
    cube.rotation.y += 0.014;
  });

  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  updateWallAndCubes();
});

// -- URL Sync for count, distance, size only --

function loadParamsFromURL() {
  const sp = new URLSearchParams(window.location.search);
  const getNum = (key, def) => {
    const val = parseFloat(sp.get(key));
    return isNaN(val) ? def : val;
  };
  params.targetCount = Math.round(getNum('count', params.targetCount));
  params.targetDistance = getNum('distance', params.targetDistance);
  params.targetSize = getNum('size', params.targetSize);
}

function updateURLFromParams() {
  const sp = new URLSearchParams();
  sp.set('count', params.targetCount);
  sp.set('distance', params.targetDistance);
  sp.set('size', params.targetSize);
  const newUrl = `${window.location.pathname}?${sp.toString()}`;
  window.history.replaceState(null, '', newUrl);
}

loadParamsFromURL();

// -- GUI Setup --

const gui = new dat.GUI({hideable:false, autoPlace:false});
gui.domElement.style.position = 'fixed';
gui.domElement.style.top = '10px';
gui.domElement.style.right = '10px';
gui.domElement.style.zIndex = "9999";
document.body.appendChild(gui.domElement);

gui.add(params, 'targetCount', 1, 10).step(1).name('Number of Targets').onChange(() => {
  adjustTargetCount();
  updateURLFromParams();
});
gui.add(params, 'targetDistance', 1, 20).step(0.1).name('Target Distance').onChange(() => {
  updateWallAndCubes();
  updateURLFromParams();
});
gui.add(params, 'targetSize', 0.2, 2).step(0.05).name('Target Size').onChange(() => {
  cubes.forEach(cube => {
    cube.geometry.dispose();
    cube.geometry = new THREE.BoxGeometry(params.targetSize, params.targetSize, params.targetSize);
    if(cube.children.length > 0){
      cube.children[0].geometry.dispose();
      cube.children[0].geometry = new THREE.BoxGeometry(params.targetSize, params.targetSize, params.targetSize);
    }
  });
  updateWallAndCubes();
  updateURLFromParams();
});

// Add color controls (not saved to URL)
gui.addColor(params, 'bgColor').name('Background Color').onChange(() => {
  renderer.setClearColor(params.bgColor);
});
gui.addColor(params, 'targetColor').name('Target Color').onChange(() => {
  updateColors();
});
gui.add(params, 'targetOpacity', 0, 1).step(0.01).name('Target Opacity').onChange(updateColors);

// Add Video Selector dropdown
gui.add(params, 'videoFile', videoFiles).name('Video Background').onChange((val) => {
  changeVideo(val);
});

// Copy Link button with temporary text feedback
const copyLinkController = gui.add({copyLink: copyLinkToClipboard}, 'copyLink').name('ðŸ“‹ Copy Link');

function copyLinkToClipboard(){
  navigator.clipboard.writeText(window.location.href).then(() => {
    copyLinkController.name('âœ… Link copied!');
    setTimeout(() => {
      copyLinkController.name('ðŸ“‹ Copy Link');
    }, 2000);
  }).catch(console.error);
}

// Video switching function
function changeVideo(filename) {
  video.pause();
  video.src = filename;
  video.load();
  video.play().catch(e => {
    console.warn("Video autoplay prevented; user interaction needed.", e);
  });
  videoTexture.needsUpdate = true;
}

let isPaused = true;
let cubes = [];
let backPlane;
const zOffset = 0.25;
const margin = 0.05;
const maxAttempts = 1000;

init();
animate();

pauseOverlay.classList.add('visible');
gui.domElement.style.display = 'block';
instructions.style.display = 'block';

document.addEventListener('keydown', e => {
  if(e.key === 'Escape'){
    if(document.pointerLockElement === renderer.domElement){
      document.exitPointerLock();
    } else if(!isPaused){
      pauseOverlay.classList.add('visible');
      gui.domElement.style.display = 'block';
      instructions.style.display = 'block';
      isPaused = true;
    }
  }
});
</script>
</body>
</html>
